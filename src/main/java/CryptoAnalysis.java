

import java.io.FileWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import static java.lang.Math.pow;
import static java.lang.Math.sqrt;

/**
 * Created by pyshankov on 16.05.2016.
 */
public class CryptoAnalysis {

    private static ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()+1);

    private static final double P1 = 0.25;
    private static final double P2 = 0.5;
    private static final double alpha = 0.01;

    private static double tb230=6.0093535655;
    private static double tb231=6.120756286;

//    private static double tb225 = 5.4199831749;
//    private static double tb226= 5.5425940578;

    public static String zi = "00011000010101111000000110101001101100001111100100011011010011000001001010110110000011010000101100110101011001011001001100010100010100010100011111110110111010000101010011001010101000010101011111110100011000100100110111110100000011000001101111000110101000111010000001010010100000100100100111110111100111110100100101010011110100101100001011110000110001100100100100011100001110110010010001000011110100100000000100100001001111111101111101000000110100011110111001101110010000010001110000111000111011100101000111101011111111011111110100111000110101001000111010100001111111011111000011000011110011011110101010101101110101111001011111100100010100100000010001011110100010010010100101101110110111110100010110100001001101111010101010111101110111001000001100101100001101110001011000010010100010110001000100000101011001000010001111001010111111000101000011110001110010010011111110110001111101110000001111111001101111000001011001111001111001110011101010011111101011001011010011111110110010000001000010100010100001000001010100001010111011011111100000000101001001100000110001101101010001010100010101011110001000000011101000011110011000110101000101001111101100101100001010011111000001100101101110001100010011011110110010111100110110000111000000000110001111010111000011101010001100001000111111110100011001110010110110100001001011001000100100011011010100000001001111100001000110111011100001011000110110100001110111010001101111011000011110101100101110001100100110100001101000000111101010101110100100011000011010111010110111100110000001101111011111010101101011010100111101100011110000111010011001001101111000011011011011010010110011011101010010000110000011111010000001100000001000110110000001101000111001000001110101010101101100111110100001010011111001000010011111001101111000001010100100011111010100111101111111100100010010111111100100010000101111101000000010100010010011100100011001111111111001100011110011000001000000011100001110111100101001100011111010010100100101110000110101000100101111110000111010000111110001000100000111000000110001111010100010010110100001001110";
//        public static String zi = "10110011001100100100101010010001010000000111100001100001101000011001110101101110001111101011111010010011111101011111110101100100011010100100011101111110100001100101001101011110110101010110100010001101001100100011100000011110110100011101000100111110001001111010011100000011100101011011101101011011111100111100100101100110111111011111111111111000011011010010100001011110110001011010110111011010001001111100001110100001010010000000011000111111110101010000001011000000001110010100111001110011101110011001010001110010100111110011010001110011001001111001001110000001000011011100001010011110011100110110101001010101100111010001100001001000101110001110110110001100101101101110100011010010111000100110011110101010011000111111100100011100000011101010011101101110001110000011100111100101001010110111001001110110000001000011010011111100010000000000110100101000001100000001001011100110111010100110100100010010000100100110011110011000010000110000110110010100111000111101000011010100101111100001001100001011101001111101100001100001100110010001111111011000000010001110101111110101010011011110110110100111010011010000011011001110100100111110000100011111010010100101100110000000100100000101101010000011101000100101011001001101000100010001010010011011000101011011101001011010011101001111010010101110011111001110100110110101100011110010010110111000101101111101010101100001000000110101101101100110111011110010000100011100000111111100110010101111010101001000110111101111111110011011111100011100111011111000011101101011000110010100001111101000100010011110010000001111011110111101101100011110010000111000000111001101101011110000111101000000111101101011111011000000000110011011101111011110101010110001100010110111100101001101000000010110001111001000101000110001100011110001000101000110011000111000101101100110101000001101110100110100111000111101101100001000010101111000110010011011011001011010011010010101000010110110000100101010101110110001011001000110010010110101101010101010110110111010101101011000011001010101010001010110101111101001010011000010001111001011110001001010";


    public static long[] fromStringToMass(String s){
        long[] z = new long[s.length()];
               for (int i = 0 ; i < z.length ; i++){
                        z[i] = Integer.parseInt(zi.substring(i,i+1));
                   }
        return z;
    }

    public static long R(LinearFeedbackShiftRegister l,long[] src){
    return  Arrays.stream(src).reduce(0,(x,y)->x+(y^l.generateNext()));
    }

    public  static List<Long> firstStates(long polynom,String s,double b){

        long degree= 63-Long.numberOfLeadingZeros(polynom);
        long numberOnElementsInField = 1 << degree ;
        double betta = 1.0/numberOnElementsInField;

        double tAlpha = 2.326347874;
        double tBetta = b;


        System.out.println("b "+tBetta);
        double a1 = tAlpha * Math.sqrt(P1 * (1 - P1));
        double a2 = tBetta * Math.sqrt(P2 * (1 - P2));

        int N = new BigDecimal(pow((a1 + a2) / (P2 - P1), 2)).setScale(0, RoundingMode.UP).intValue();
        new BigDecimal(N * P1 + sqrt(N) * a1).setScale(0, RoundingMode.UP).intValue();
        double C = new BigDecimal(N * P1 + sqrt(N) * a1).setScale(0, RoundingMode.UP).intValue();

        System.out.println("N*"+ N);
        System.out.println("C "+C);

        long[] z = new long[N];
        System.arraycopy(fromStringToMass(s),0,z,0,z.length-1);

        List<Long> res = new ArrayList<>();

        for (long i = 0 ; i < numberOnElementsInField ; i ++){
            LinearFeedbackShiftRegister l = new LinearFeedbackShiftRegister(polynom,i);
            long R = R(l,z);
            if(R<=C) res.add(i);
        }
        return res;
    }

    public static void breakGeffe(long p1,long p2,long p3,String s) throws Exception{

         Callable<List<Long>> L1StatesTask = ()-> CryptoAnalysis.firstStates(p1,CryptoAnalysis.zi,tb230);
         Callable<List<Long>> L2StatesTask = ()-> CryptoAnalysis.firstStates(p2,CryptoAnalysis.zi,tb231);

        long degree= 63-Long.numberOfLeadingZeros(p3);
        long numberOnElementsInField = 1 << degree ;

        long[] z = new long[s.length()];
        System.arraycopy(fromStringToMass(s),0,z,0,z.length-1);

        Future<List<Long>> future1 = executorService.submit(L1StatesTask);
        Future<List<Long>> future2 = executorService.submit(L2StatesTask);

        executorService.shutdown();

        long t = System.currentTimeMillis();
        List<Long> l1Res = future1.get();
        List<Long> l2Res = future2.get();
        System.out.println(System.currentTimeMillis()-t);

        System.out.println(l1Res.size());
        System.out.println(l2Res.size());

        for (Long l1 : l1Res){
            LinearFeedbackShiftRegister L1 = new LinearFeedbackShiftRegister(p1,l1);
            for (Long l2 : l2Res){
                LinearFeedbackShiftRegister L2 = new LinearFeedbackShiftRegister(p2,l2);
                for (long i = 0 ; i < numberOnElementsInField ; i++){
                    L1.reset();
                    L2.reset();
                    LinearFeedbackShiftRegister L3 = new LinearFeedbackShiftRegister(p3,i);
                    LinearFeedbackShiftRegister.GeffeGen geffeGen = new LinearFeedbackShiftRegister.GeffeGen(L1,L2,L3);
                    boolean d = true;
                    for(int j = 0 ; j < z.length ; j++){
                        if(z[j]!=geffeGen.getNext()){
                            d=false;
                            break;
                        }
                    }
                    if(d) {
                        try (FileWriter fw = new FileWriter("res_hard.txt")) {
                            fw.write(L1.getFirstState() + "\n");
                            fw.write(L2.getFirstState() + "\n");
                            fw.write(L3.getFirstState() + "\n");

                            fw.write(L1.getCurrentState() + "\n");
                            fw.write(L2.getCurrentState() + "\n");
                            fw.write(L3.getCurrentState() + "\n");
                        } catch (IOException e) {
                        }
                    }

                }
            }

        }
        executorService.shutdown();
    }

}



